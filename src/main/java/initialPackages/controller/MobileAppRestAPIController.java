package initialPackages.controller;

//https://spring.io/guides/gs/accessing-data-mysql/
//Create a new controller for your Spring application

import initialPackages.UserRepository;
import initialPackages.User;
import java.security.Principal;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller //This annotation makes the class a controller.
@RequestMapping(path="/mobile-api") //URLs start with /mobile-api (after the application path)
public class MobileAppRestAPIController {
    
    @Autowired //Get the bean called userRepository,
               //Which is auto-generated by spring, 
    private UserRepository userRepository;
    
    
    //We want to add security to this function so that users cannot create multiple accounts.
    
    @GetMapping(path="/add") //A GetMapping annotation maps only GET requests.
    public @ResponseBody String addNewUser (@RequestParam String accessCode){
        //Using the @ResponseBody annotation here means the returned String is the response, not a view name.
        //Usually we return a view name for displaying a new HTML page on the website.
        //The @RequestParam annotation signifies that the parameter is from the GET or POST request
        
        User n = new User();
        n.setAccessCode(accessCode);
        //Using accessCode like this is NOT a good idea.
        //HMMMMM...
        
        userRepository.save(n);
        return "Saved";
    }
    
    // We want to add security to this function so that the user can update data with their ID, but nobody elses.
    
    // A promising start seems to be... 
    // https://stackoverflow.com/questions/51712724/how-to-allow-a-user-only-access-their-own-data-in-spring-boot-spring-security
    
    @GetMapping(path="/update/{userID}")
    public @ResponseBody String updateHabitData (@PathVariable("user_id") Long userId, 
                                                 @RequestParam String habitData,
                                                 Principal principal){
        
        // Apparently we can test if userId is current principal. What is a principal?
        
        // https://stackoverflow.com/questions/37499307/whats-the-principal-in-spring-security
        
        // The Principle is the current logged in user accessing the server resources.
        // It only refers to one user accessing one thread of the server, so you don't have to worry about multiple principles.
        // The servlet container differentiates between the principles that are doing the requests.
       
        // The next question is, will authentication through OAuth2 be recognised 
        // by Spring Security as a user "logging in" to their account?
        
        return "Updated";
    }
    
    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers(){
        return userRepository.findAll();
    }
}

//The annotation @GetMapping is shorthand for @RequestMapping(method="GET")
//It doesn't specify between GET vs PUT or POST.
